{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { tagInternalFilter } from '@mui/x-data-grid-pro/internals';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n    return params.row[params.field];\n  };\n  return wrappedValueGetter;\n};\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n    return params.value;\n  };\n  return wrappedValueFormatter;\n};\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n        return params.formattedValue;\n      }\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n    return renderCell(params);\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Skips the filtering for aggregated rows\n */\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  apiRef,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  const baseGetApplyFilterFn = operator.getApplyFilterFn;\n  const baseGetApplyFilterFnV7 = operator.getApplyFilterFnV7;\n  const getApplyFilterFn = tagInternalFilter((filterItem, colDef) => {\n    const filterFn = baseGetApplyFilterFn(filterItem, colDef);\n    if (!filterFn) {\n      return null;\n    }\n    return params => {\n      if (getCellAggregationResult(params.id, params.field) != null) {\n        return true;\n      }\n      return filterFn(params);\n    };\n  });\n  const getApplyFilterFnV7 = baseGetApplyFilterFnV7 === undefined ? undefined : tagInternalFilter((filterItem, colDef) => {\n    const filterFn = baseGetApplyFilterFnV7(filterItem, colDef);\n    if (!filterFn) {\n      return null;\n    }\n    return (value, row, column, api) => {\n      if (getCellAggregationResult(apiRef.current.getRowId(row), column.field) != null) {\n        return true;\n      }\n      return filterFn(value, row, column, api);\n    };\n  });\n  return _extends({}, operator, {\n    getApplyFilterFn,\n    getApplyFilterFnV7\n  });\n});\n\n/**\n * Add the aggregation method around the header name\n */\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderHeader = params => {\n    const aggregation = {\n      aggregationRule\n    };\n    if (renderHeader) {\n      return renderHeader(_extends({}, params, {\n        aggregation\n      }));\n    }\n    return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n      aggregation: aggregation\n    }));\n  };\n  return wrappedRenderHeader;\n};\n\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\nexport const wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$parent, _gridAggregationLooku;\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n    if (cellAggregationPosition == null) {\n      return null;\n    }\n\n    // TODO: Add custom root id\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)) == null || (_gridAggregationLooku = _gridAggregationLooku[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n    return aggregationResult;\n  };\n  let didWrapSomeProperty = false;\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedColumn: column\n  });\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n    if (wrappedProperty !== originalValue) {\n      didWrapSomeProperty = true;\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n  if (!didWrapSomeProperty) {\n    return column;\n  }\n  return wrappedColumn;\n};\n\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\nexport const unwrapColumnFromAggregation = ({\n  column\n}) => {\n  var _aggregationWrappedCo;\n  return (_aggregationWrappedCo = column.aggregationWrappedColumn) != null ? _aggregationWrappedCo : column;\n};","map":{"version":3,"names":["_extends","React","tagInternalFilter","gridAggregationLookupSelector","GridFooterCell","GridAggregationHeader","jsx","_jsx","AGGREGATION_WRAPPABLE_PROPERTIES","getAggregationValueWrappedValueGetter","value","valueGetter","getCellAggregationResult","wrappedValueGetter","params","cellAggregationResult","id","field","_cellAggregationResul","row","getAggregationValueWrappedValueFormatter","valueFormatter","aggregationRule","aggregationFunction","wrappedValueFormatter","getAggregationValueWrappedRenderCell","renderCell","wrappedRenderCell","_aggregationFunction$","position","formattedValue","aggregationMeta","hasCellUnit","aggregationFunctionName","aggregation","getWrappedFilterOperators","filterOperators","apiRef","map","operator","baseGetApplyFilterFn","getApplyFilterFn","baseGetApplyFilterFnV7","getApplyFilterFnV7","filterItem","colDef","filterFn","undefined","column","api","current","getRowId","getWrappedRenderHeader","renderHeader","wrappedRenderHeader","wrapColumnWithAggregationValue","_rowNode$parent","_gridAggregationLooku","cellAggregationPosition","rowNode","getRowNode","type","toString","startsWith","groupId","parent","aggregationResult","didWrapSomeProperty","wrappedColumn","aggregationWrappedColumn","wrapColumnProperty","property","wrapper","originalValue","wrappedProperty","unwrapColumnFromAggregation","_aggregationWrappedCo"],"sources":["D:/work/tipa-report-system/frontend/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/wrapColumnWithAggregation.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { tagInternalFilter } from '@mui/x-data-grid-pro/internals';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n    return params.row[params.field];\n  };\n  return wrappedValueGetter;\n};\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n    return params.value;\n  };\n  return wrappedValueFormatter;\n};\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n        return params.formattedValue;\n      }\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n    return renderCell(params);\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Skips the filtering for aggregated rows\n */\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  apiRef,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  const baseGetApplyFilterFn = operator.getApplyFilterFn;\n  const baseGetApplyFilterFnV7 = operator.getApplyFilterFnV7;\n  const getApplyFilterFn = tagInternalFilter((filterItem, colDef) => {\n    const filterFn = baseGetApplyFilterFn(filterItem, colDef);\n    if (!filterFn) {\n      return null;\n    }\n    return params => {\n      if (getCellAggregationResult(params.id, params.field) != null) {\n        return true;\n      }\n      return filterFn(params);\n    };\n  });\n  const getApplyFilterFnV7 = baseGetApplyFilterFnV7 === undefined ? undefined : tagInternalFilter((filterItem, colDef) => {\n    const filterFn = baseGetApplyFilterFnV7(filterItem, colDef);\n    if (!filterFn) {\n      return null;\n    }\n    return (value, row, column, api) => {\n      if (getCellAggregationResult(apiRef.current.getRowId(row), column.field) != null) {\n        return true;\n      }\n      return filterFn(value, row, column, api);\n    };\n  });\n  return _extends({}, operator, {\n    getApplyFilterFn,\n    getApplyFilterFnV7\n  });\n});\n\n/**\n * Add the aggregation method around the header name\n */\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderHeader = params => {\n    const aggregation = {\n      aggregationRule\n    };\n    if (renderHeader) {\n      return renderHeader(_extends({}, params, {\n        aggregation\n      }));\n    }\n    return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n      aggregation: aggregation\n    }));\n  };\n  return wrappedRenderHeader;\n};\n\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\nexport const wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$parent, _gridAggregationLooku;\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n    if (cellAggregationPosition == null) {\n      return null;\n    }\n\n    // TODO: Add custom root id\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)) == null || (_gridAggregationLooku = _gridAggregationLooku[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n    return aggregationResult;\n  };\n  let didWrapSomeProperty = false;\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedColumn: column\n  });\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n    if (wrappedProperty !== originalValue) {\n      didWrapSomeProperty = true;\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n  if (!didWrapSomeProperty) {\n    return column;\n  }\n  return wrappedColumn;\n};\n\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\nexport const unwrapColumnFromAggregation = ({\n  column\n}) => {\n  var _aggregationWrappedCo;\n  return (_aggregationWrappedCo = column.aggregationWrappedColumn) != null ? _aggregationWrappedCo : column;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}